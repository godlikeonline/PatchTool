
##############################################################################
# Big rocks
##############################################################################

1. No dependencies (in either direction) between hash-and-cache and cache
   queries.  They should be completely independent of one another.

2. Hash 


##############################################################################
# Workflow
##############################################################################

1. Load binaries table -- semi-automated.  Use Aristotle_sources.config as the
   template.  Check out SQL CSV autoloading.

   http://blog.sqlauthority.com/2008/02/06/sql-server-import-csv-file-into-sql-server-using-bulk-insert-load-comma-delimited-file-into-sql-server/

2. Run build as usual.

3. Insert build record: manual at first?

4. Query binaries table for list of binaries and paths.  Need to design a
   query to get the required data.

5. Iterate over the list, collect each file, hash and stash.  Prefer central
   storage, maybe Amazon S3?  Don't complicate things at first.  Make it easy
   to mirror / distribute for safety & redundancy.

6. Profit!


##############################################################################
# UI
##############################################################################

1. Front end: web site or Windows form?  Decide later?

2. Need views for:
    - adding a new binary
    - adding a new build (binary instances)
    - ad hoc searches?  (no)
    - 

@@@@

===Issues with getting new binaries into the DB===

Accessibility issue no. 1:
    Server runs on one machine, clients somewhere else

Accessibility issue no. 2:
    Server doesn't have a copy of the new (folder and) file.  They're on the
    client's machine.

Accessibility issue no. 3:
    Path data not available, and even if it was, see nos. 1 & 2.

Conclusion:
    The users will have to carefully add the path from the wc_root to the new
    file.


##############################################################################
# Questions
##############################################################################
What does data entry look like with this database?  If we had a view, what
would it take as input?

Also, how and where to encode the binary targets?  They're not here yet.



##############################################################################
# table:    branches
# PK:       branch_id
# FK:       none
##############################################################################
CREATE TABLE [dbo].[branches]
(
    [branch_id] INT NOT NULL,
    [repository_path] NVARCHAR(255) NOT NULL,
    [friendly_name] NVARCHAR(255),

    CONSTRAINT [PK_branch_id]
    PRIMARY KEY CLUSTERED ([branch_id])
)

##############################################################################
# table:    build
# PK:       build_id
# FK:       none
##############################################################################
CREATE TABLE [dbo].[build]
(
    [build_id] INT NOT NULL,
    [branch_id] INT NOT NULL,
    [build_date] DATETIME,
    [build_machine] NVARCHAR(255),
    [build_version] NVARCHAR(255) NOT NULL,
    [build_number] INT NOT NULL,
    [wc_root] NVARCHAR(255),
    [revision] INT,

    CONSTRAINT [PK_build_id]
    PRIMARY KEY CLUSTERED ([build_id]),

    CONSTRAINT [FK_branch_id__build_id]
    FOREIGN KEY([branch_id])
    REFERENCES [dbo].[build] ([build_id]),
)

##############################################################################
# table:    binaries
# PK:       binary_id
# FK:       none
##############################################################################
CREATE TABLE [dbo].[binaries]
(
    [binary_id] INT NOT NULL,
    [name] NVARCHAR(255),
    [build_path] NVARCHAR(255) NOT NULL,

    CONSTRAINT [PK_binary_id]
    PRIMARY KEY CLUSTERED ([binary_id])
)

##############################################################################
# table:    binary_instances
# PK:       none
# FK:       binaries.binary_id, build.build_id
##############################################################################
CREATE TABLE [dbo].[binary_instances]
(
    [binary_id] INT NOT NULL,
    [build_id] INT NOT NULL,
    [md5sum] NVARCHAR(255) NOT NULL,
    [binary_version] NVARCHAR(255) NOT NULL,

    CONSTRAINT [FK_binary_instances__binary_id]
    FOREIGN KEY([binary_id])
    REFERENCES [dbo].[binaries] ([binary_id]),

    CONSTRAINT [FK_binary_instances__build_id]
    FOREIGN KEY([build_id])
    REFERENCES [dbo].[build] ([build_id]),
)

